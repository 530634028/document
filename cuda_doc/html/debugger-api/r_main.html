<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-us" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="copyright" content="(C) Copyright 2005"></meta>
      <meta name="DC.rights.owner" content="(C) Copyright 2005"></meta>
      <meta name="DC.Type" content="cuda_reference"></meta>
      <meta name="DC.Title" content="Introduction"></meta>
      <meta name="DC.Format" content="XHTML"></meta>
      <meta name="DC.Identifier" content="r_main"></meta>
      <link rel="stylesheet" type="text/css" href="../common/formatting/commonltr.css"></link>
      <link rel="stylesheet" type="text/css" href="../common/formatting/site.css"></link>
      <title>Debugger API :: CUDA Toolkit Documentation</title>
      <!--[if lt IE 9]>
      <script src="../common/formatting/html5shiv-printshiv.min.js"></script>
      <![endif]-->
      <script type="text/javascript" charset="utf-8" src="../common/scripts/tynt/tynt.js"></script>
      <script type="text/javascript" charset="utf-8" src="../common/formatting/jquery.min.js"></script>
      <script type="text/javascript" charset="utf-8" src="../common/formatting/jquery.ba-hashchange.min.js"></script>
      <script type="text/javascript" charset="utf-8" src="../common/formatting/jquery.scrollintoview.min.js"></script>
      <script type="text/javascript" src="../search/htmlFileList.js"></script>
      <script type="text/javascript" src="../search/htmlFileInfoList.js"></script>
      <script type="text/javascript" src="../search/nwSearchFnt.min.js"></script>
      <script type="text/javascript" src="../search/stemmers/en_stemmer.min.js"></script>
      <script type="text/javascript" src="../search/index-1.js"></script>
      <script type="text/javascript" src="../search/index-2.js"></script>
      <script type="text/javascript" src="../search/index-3.js"></script>
      <link rel="canonical" href="http://docs.nvidia.com/cuda/debugger-api/index.html"></link>
      <link rel="stylesheet" type="text/css" href="../common/formatting/qwcode.highlight.css"></link>
   </head>
   <body>
      
      <header id="header"><span id="company">NVIDIA</span><span id="site-title">CUDA Toolkit Documentation</span><form id="search" method="get" action="search">
            <input type="text" name="search-text"></input><fieldset id="search-location">
               <legend>Search In:</legend>
               <label><input type="radio" name="search-type" value="site"></input>Entire Site</label>
               <label><input type="radio" name="search-type" value="document"></input>Just This Document</label></fieldset>
            <button type="reset">clear search</button>
            <button id="submit" type="submit">search</button></form>
      </header>
      <div id="site-content">
         <nav id="site-nav">
            <div class="category closed"><a href="../index.html" title="The root of the site.">CUDA Toolkit
                  v8.0</a></div>
            <div class="category"><a href="index.html" title="Debugger API">Debugger API</a></div>
            <ul>
               <li>
                  <div class="section-link"><a href="release-notes.html#release-notes">1.&nbsp;Release Notes</a></div>
                  <ul>
                     <li>
                        <div class="section-link"><a href="release-notes.html#about-this-document">1.1.&nbsp;7.0 Release</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="release-notes.html#unique_1074615893">1.2.&nbsp;6.5 Release</a></div>
                     </li>
                  </ul>
               </li>
               <li>
                  <div class="section-link"><a href="r_main.html#r_main">2.&nbsp;Introduction</a></div>
                  <ul>
                     <li>
                        <div class="section-link"><a href="r_main.html#r_api">2.1.&nbsp;Debugger API</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="r_main.html#r_elf">2.2.&nbsp;ELF and DWARF</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="r_main.html#r_abi31">2.3.&nbsp;ABI Support</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="r_main.html#r_exceptions31">2.4.&nbsp;Exception Reporting</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="r_main.html#r_attach">2.5.&nbsp;Attaching and Detaching</a></div>
                     </li>
                  </ul>
               </li>
               <li>
                  <div class="section-link"><a href="modules.html#modules">3.&nbsp;Modules</a></div>
                  <ul>
                     <li>
                        <div class="section-link"><a href="group__GENERAL.html#group__GENERAL">3.1.&nbsp;General</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="group__INIT.html#group__INIT">3.2.&nbsp;Initialization</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="group__EXEC.html#group__EXEC">3.3.&nbsp;Device Execution Control</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="group__BP.html#group__BP">3.4.&nbsp;Breakpoints</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="group__READ.html#group__READ">3.5.&nbsp;Device State Inspection</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="group__WRITE.html#group__WRITE">3.6.&nbsp;Device State Alteration</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="group__GRID.html#group__GRID">3.7.&nbsp;Grid Properties</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="group__DEV.html#group__DEV">3.8.&nbsp;Device Properties</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="group__DWARF.html#group__DWARF">3.9.&nbsp;DWARF Utilities</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="group__EVENT.html#group__EVENT">3.10.&nbsp;Events</a></div>
                     </li>
                  </ul>
               </li>
               <li>
                  <div class="section-link"><a href="annotated.html#annotated">4.&nbsp;Data Structures</a></div>
                  <ul>
                     <li>
                        <div class="section-link"><a href="structCUDBGAPI__st.html#structCUDBGAPI__st">4.1.&nbsp;CUDBGAPI_st</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="structCUDBGEvent.html#structCUDBGEvent">4.2.&nbsp;CUDBGEvent</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="unionCUDBGEvent_1_1cases__st.html#unionCUDBGEvent_1_1cases__st">4.3.&nbsp;CUDBGEvent::cases_st</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="structCUDBGEvent_1_1cases__st_1_1contextCreate__st.html#structCUDBGEvent_1_1cases__st_1_1contextCreate__st">4.4.&nbsp;CUDBGEvent::cases_st::contextCreate_st</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="structCUDBGEvent_1_1cases__st_1_1contextDestroy__st.html#structCUDBGEvent_1_1cases__st_1_1contextDestroy__st">4.5.&nbsp;CUDBGEvent::cases_st::contextDestroy_st</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="structCUDBGEvent_1_1cases__st_1_1contextPop__st.html#structCUDBGEvent_1_1cases__st_1_1contextPop__st">4.6.&nbsp;CUDBGEvent::cases_st::contextPop_st</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="structCUDBGEvent_1_1cases__st_1_1contextPush__st.html#structCUDBGEvent_1_1cases__st_1_1contextPush__st">4.7.&nbsp;CUDBGEvent::cases_st::contextPush_st</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="structCUDBGEvent_1_1cases__st_1_1elfImageLoaded__st.html#structCUDBGEvent_1_1cases__st_1_1elfImageLoaded__st">4.8.&nbsp;CUDBGEvent::cases_st::elfImageLoaded_st</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="structCUDBGEvent_1_1cases__st_1_1internalError__st.html#structCUDBGEvent_1_1cases__st_1_1internalError__st">4.9.&nbsp;CUDBGEvent::cases_st::internalError_st</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="structCUDBGEvent_1_1cases__st_1_1kernelFinished__st.html#structCUDBGEvent_1_1cases__st_1_1kernelFinished__st">4.10.&nbsp;CUDBGEvent::cases_st::kernelFinished_st</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="structCUDBGEvent_1_1cases__st_1_1kernelReady__st.html#structCUDBGEvent_1_1cases__st_1_1kernelReady__st">4.11.&nbsp;CUDBGEvent::cases_st::kernelReady_st</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="structCUDBGEventCallbackData.html#structCUDBGEventCallbackData">4.12.&nbsp;CUDBGEventCallbackData</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="structCUDBGEventCallbackData40.html#structCUDBGEventCallbackData40">4.13.&nbsp;CUDBGEventCallbackData40</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="structCUDBGGridInfo.html#structCUDBGGridInfo">4.14.&nbsp;CUDBGGridInfo</a></div>
                     </li>
                  </ul>
               </li>
               <li>
                  <div class="section-link"><a href="functions.html#functions">5.&nbsp;Data Fields</a></div>
               </li>
               <li>
                  <div class="section-link"><a href="deprecated.html#deprecated">6.&nbsp;Deprecated List</a></div>
               </li>
               <li>
                  <div class="section-link"><a href="notices-header.html#notices-header">Notices</a></div>
                  <ul></ul>
               </li>
            </ul>
         </nav>
         <div id="resize-nav"></div>
         <nav id="search-results">
            <h2>Search Results</h2>
            <ol></ol>
         </nav>
         
         <div id="contents-container">
            <div id="breadcrumbs-container">
               <div id="breadcrumbs"><a href="release-notes.html" shape="rect">&lt; Previous</a> | <a href="modules.html" shape="rect">Next &gt;</a></div>
               <div id="release-info">Debugger API
                  (<a href="../../pdf/CUDA_Debugger_API.pdf">PDF</a>)
                  -
                  
                  v8.0
                  (<a href="https://developer.nvidia.com/cuda-toolkit-archive">older</a>)
                  -
                  Last updated January 11, 2017
                  -
                  <a href="mailto:cudatools@nvidia.com?subject=CUDA Toolkit Documentation Feedback: Debugger API">Send Feedback</a>
                  -
                  <span class="st_facebook"></span><span class="st_twitter"></span><span class="st_linkedin"></span><span class="st_reddit"></span><span class="st_slashdot"></span><span class="st_tumblr"></span><span class="st_sharethis"></span></div>
            </div>
            <article id="contents">
               <div class="topic nested1" id="r_main"><a name="r_main" shape="rect">
                     <!-- --></a><h2 class="topictitle2">2.&nbsp;Introduction</h2>
                  <div class="body refbody">
                     <div class="section">
                        <p class="p">This document describes the API for the set routines and data structures available in
                           the CUDA library to any debugger.
                        </p>
                     </div>
                     <div class="section">
                        <div class="p">Starting with 3.0, the CUDA debugger API includes several major changes, of which only
                           few are directly visible to end-users: 
                           <ul class="ul">
                              <li class="li">
                                 <p class="p">Performance is greatly improved, both with respect to interactions with the
                                    debugger and the performance of applications being debugged. 
                                 </p>
                              </li>
                              <li class="li">
                                 <p class="p">The format of cubins has changed to ELF and, as a consequence, most
                                    restrictions on debug compilations have been lifted. More information about the
                                    new object format is included below.
                                 </p>
                              </li>
                           </ul>
                           
                           The debugger API has significantly changed, reflected in the CUDA-GDB sources.
                        </div>
                     </div>
                  </div>
                  <div class="topic reference cuda_reference nested1" id="r_api"><a name="r_api" shape="rect">
                        <!-- --></a><h3 class="topictitle3">2.1.&nbsp;Debugger API</h3>
                     <div class="body refbody">
                        <div class="section">
                           <p class="p">The CUDA Debugger API was developed with the goal of adhering to the following principles:</p>
                           <div class="p">
                              <ul class="ul">
                                 <li class="li">
                                    <p class="p">Policy free </p>
                                 </li>
                                 <li class="li">
                                    <p class="p">Explicit </p>
                                 </li>
                                 <li class="li">
                                    <p class="p">Axiomatic </p>
                                 </li>
                                 <li class="li">
                                    <p class="p">Extensible </p>
                                 </li>
                                 <li class="li">
                                    <p class="p">Machine oriented</p>
                                 </li>
                              </ul>
                              
                              
                              Being explicit is another way of saying that we minimize the assumptions we make. As much as possible the API reflects machine
                              state, not internal state.
                           </div>
                           <p class="p">There are two major "modes" of the devices: stopped or running. We switch between these modes explicitly with suspendDevice
                              and resumeDevice, though the machine may suspend on its own accord, for example when hitting a breakpoint.
                           </p>
                           <p class="p">Only when stopped, can we query the machine's state. Warp state includes which function is it runnning, which block, which
                              lanes are valid, etc.
                           </p>
                           <p class="p">As of CUDA 6.0, state collection functions in the debug API will return CUDBG_ERROR_RUNNING_DEVICE if called without first
                              calling the suspendDevice entry point to ensure the device is stopped.
                              
                           </p>
                           <p class="p">Clients of the debug API should suspend all devices before servicing a <a href="structCUDBGEvent.html" shape="rect">CUDBGEvent</a>. A valid CUDBGEvent is only guaranteed to be returned after the notification callback set using <a href="group__EVENT.html#group__EVENT_1g42642d4e8dfb372d730d2a49ae6acd25" shape="rect">CUDBGAPI_st::setNotifyNewEventCallback()</a> is executed. Any debug API entry point will return CUDBG_ERROR_RECURSIVE_API_CALL when the call is made from within the notification
                              callback set using <a href="group__EVENT.html#group__EVENT_1g42642d4e8dfb372d730d2a49ae6acd25" shape="rect">CUDBGAPI_st::setNotifyNewEventCallback()</a>. 
                           </p>
                        </div>
                     </div>
                  </div>
                  <div class="topic reference cuda_reference nested1" id="r_elf"><a name="r_elf" shape="rect">
                        <!-- --></a><h3 class="topictitle3">2.2.&nbsp;ELF and DWARF</h3>
                     <div class="body refbody">
                        <div class="section">
                           <p class="p">CUDA applications are compiled in ELF binary format.</p>
                           <p class="p">Starting with CUDA 6.0, DWARF device information is obtained through an API call of <a href="group__DWARF.html#group__DWARF_1gb5bc313ab611a302aa214a94a960067e" shape="rect">CUDBGAPI_st::getElfImageByHandle</a> using the handle exposed from <a href="structCUDBGEvent.html" shape="rect">CUDBGEvent</a> of type CUDBG_EVENT_ELF_IMAGE_LOADED. This means that the information is not available until runtime, after the CUDA driver
                              has loaded. The DWARF device information lifetime is valid until it is unloaded, which presents a <a href="structCUDBGEvent.html" shape="rect">CUDBGEvent</a> of type CUDBG_EVENT_ELF_IMAGE_UNLOADED.
                           </p>
                           <p class="p">In CUDA 5.5 and earlier, the DWARF device information was returned as part of the <a href="INVALID_DOXYREF" class="error" shape="rect">INVALID_DOXYREF</a> of type CUDBG_EVENT_ELF_IMAGE_LOADED. The pointers presented in CUDBGEvent55 were read-only pointers to memory managed by
                              the debug API. The memory pointed to was implicitly scoped to the lifetime of the loading CUDA context. Accessing the returned
                              pointers after the context was destroyed resulted in undefined behavior.
                           </p>
                           <p class="p">DWARF device information contains physical addresses for all device memory regions except for code memory. The address class
                              field (DW_AT_address_class) is set for all device variables, and is used to indicate the memory segment type (ptxStorageKind).
                              The physical addresses must be accessed using several segment-specific API calls.
                           </p>
                           <div class="p">For memory reads, see: 
                              <ul class="ul">
                                 <li class="li">
                                    <p class="p"><a href="group__READ.html#group__READ_1g96d8d7f7158aacc75b0013fb14e070df" shape="rect">CUDBGAPI_st::readCodeMemory()</a></p>
                                 </li>
                                 <li class="li">
                                    <p class="p"><a href="group__READ.html#group__READ_1g403214b4c091fa8f1805e652fa720717" shape="rect">CUDBGAPI_st::readConstMemory()</a></p>
                                 </li>
                                 <li class="li">
                                    <p class="p"><a href="group__READ.html#group__READ_1gbb7f10629d91480e5aa8aa17807b07f2" shape="rect">CUDBGAPI_st::readGlobalMemory()</a></p>
                                 </li>
                                 <li class="li">
                                    <p class="p"><a href="group__READ.html#group__READ_1g2f5bf430b5202e893f896a4e53e7473e" shape="rect">CUDBGAPI_st::readParamMemory()</a></p>
                                 </li>
                                 <li class="li">
                                    <p class="p"><a href="group__READ.html#group__READ_1ge242a5b3d2877bb06e69b29e08079d04" shape="rect">CUDBGAPI_st::readSharedMemory()</a></p>
                                 </li>
                                 <li class="li">
                                    <p class="p"><a href="group__READ.html#group__READ_1g81729a1eb1b4d90e63f505bc4e407917" shape="rect">CUDBGAPI_st::readLocalMemory()</a></p>
                                 </li>
                                 <li class="li">
                                    <p class="p"><a href="group__READ.html#group__READ_1g0d793af43e61047ee8069835d4407819" shape="rect">CUDBGAPI_st::readTextureMemory()</a></p>
                                 </li>
                              </ul>
                              
                              
                              For memory writes, see: 
                              <ul class="ul">
                                 <li class="li">
                                    <p class="p"><a href="group__WRITE.html#group__WRITE_1g58c3dc569a2c556797be6b4435fc9869" shape="rect">CUDBGAPI_st::writeGlobalMemory()</a></p>
                                 </li>
                                 <li class="li">
                                    <p class="p"><a href="group__WRITE.html#group__WRITE_1gf2396f87598ff9edb9c2cf0d0d9e51c2" shape="rect">CUDBGAPI_st::writeParamMemory()</a></p>
                                 </li>
                                 <li class="li">
                                    <p class="p"><a href="group__WRITE.html#group__WRITE_1gec20ac438034a0a94f548ee9c1cf13cc" shape="rect">CUDBGAPI_st::writeSharedMemory()</a></p>
                                 </li>
                                 <li class="li">
                                    <p class="p"><a href="group__WRITE.html#group__WRITE_1g8552847e859c3014eb5cf021ca1a07ff" shape="rect">CUDBGAPI_st::writeLocalMemory()</a></p>
                                 </li>
                              </ul>
                              
                              
                              Access to code memory requires a virtual address. This virtual address is embedded for all device code sections in the device
                              ELF image. See the API call: 
                              <ul class="ul">
                                 <li class="li">
                                    <p class="p"><a href="group__READ.html#group__READ_1gb8f4830c29701bae9198de2351f51985" shape="rect">CUDBGAPI_st::readVirtualPC()</a></p>
                                 </li>
                              </ul>
                              
                              
                              Here is a typical DWARF entry for a device variable located in memory:
                           </div>
                           <div class="p"><pre xml:space="preserve">&lt;2&gt;&lt;321&gt;: Abbrev Number: 18 (DW_TAG_formal_parameter)
     DW_AT_decl_file   : 27
     DW_AT_decl_line   : 5
     DW_AT_name        : res
     DW_AT_type        : &lt;2c6&gt;
     DW_AT_location    : 9 byte block: 3 18 0 0 0 0 0 0 0       (DW_OP_addr: 18)
     DW_AT_address_class: 7</pre></div>
                           <p class="p">The above shows that variable 'res' has an address class of 7 (ptxParamStorage). Its location information shows it is located
                              at address 18 within the parameter memory segment.
                           </p>
                           <p class="p">Local variables are no longer spilled to local memory by default. The DWARF now contains variable-to-register mapping and
                              liveness information for all variables. It can be the case that variables are spilled to local memory, and this is all contained
                              in the DWARF information which is ULEB128 encoded (as a DW_OP_regx stack operation in the DW_AT_location attribute).
                           </p>
                           <p class="p">Here is a typical DWARF entry for a variable located in a local register:</p>
                           <div class="p"><pre xml:space="preserve">&lt;3&gt;&lt;359&gt;: Abbrev Number: 20 (DW_TAG_variable)
     DW_AT_decl_file   : 27
     DW_AT_decl_line   : 7
     DW_AT_name        : c
     DW_AT_type        : &lt;1aa&gt;
     DW_AT_location    : 7 byte block: 90 b9 e2 90 b3 d6 4      (DW_OP_regx: 160631632185)
     DW_AT_address_class: 2</pre></div>
                           <p class="p">This shows variable 'c' has address class 2 (ptxRegStorage) and its location can be found by decoding the ULEB128 value, DW_OP_regx:
                              160631632185. See cuda-tdep.c in the cuda-gdb source drop for information on decoding this value and how to obtain which physical
                              register holds this variable during a specific device PC range.
                           </p>
                           <div class="p"> Access to physical registers liveness information requires a 0-based physical PC. See the API call: 
                              <ul class="ul">
                                 <li class="li">
                                    <p class="p"><a href="group__READ.html#group__READ_1g4e5d98dced2544bbe90d0a9483527f3f" shape="rect">CUDBGAPI_st::readPC()</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                  </div>
                  <div class="topic reference cuda_reference nested1" id="r_abi31"><a name="r_abi31" shape="rect">
                        <!-- --></a><h3 class="topictitle3">2.3.&nbsp;ABI Support</h3>
                     <div class="body refbody">
                        <div class="section">
                           <div class="p">ABI support is handled through the following thread API calls: 
                              <ul class="ul">
                                 <li class="li">
                                    <p class="p"><a href="group__READ.html#group__READ_1g6b438d1fd6d089bc430dd8ba6b53daf8" shape="rect">CUDBGAPI_st::readCallDepth()</a></p>
                                 </li>
                                 <li class="li">
                                    <p class="p"><a href="group__READ.html#group__READ_1g31dee949a5b53d5c509668c764ec9171" shape="rect">CUDBGAPI_st::readReturnAddress()</a></p>
                                 </li>
                                 <li class="li">
                                    <p class="p"><a href="group__READ.html#group__READ_1ga2b518d57cfab4feba42e1fcfffb5913" shape="rect">CUDBGAPI_st::readVirtualReturnAddress()</a></p>
                                 </li>
                              </ul>
                              
                              
                              The return address is not accessible on the local stack and the API call must be used to access its value.
                           </div>
                           <p class="p">For more information, please refer to the ABI documentation titled "Fermi ABI: Application Binary Interface".</p>
                        </div>
                     </div>
                  </div>
                  <div class="topic reference cuda_reference nested1" id="r_exceptions31"><a name="r_exceptions31" shape="rect">
                        <!-- --></a><h3 class="topictitle3">2.4.&nbsp;Exception Reporting</h3>
                     <div class="body refbody">
                        <div class="section">
                           <div class="p">Some kernel exceptions are reported as device events and accessible via the API call: 
                              <ul class="ul">
                                 <li class="li">
                                    <p class="p"><a href="group__READ.html#group__READ_1g67afc64c7b4e87e14bad401242a2077a" shape="rect">CUDBGAPI_st::readLaneException()</a></p>
                                 </li>
                              </ul>
                              
                              
                              The reported exceptions are listed in the CUDBGException_t enum type. Each prefix, (Device, Warp, Lane), refers to the precision
                              of the exception. That is, the lowest known execution unit that is responsible for the origin of the exception. All lane errors
                              are precise; the exact instruction and lane that caused the error are known. Warp errors are typically within a few instructions
                              of where the actual error occurred, but the exact lane within the warp is not known. On device errors, we <em class="ph i">may</em> know the <em class="ph i">kernel</em> that caused it. Explanations about each exception type can be found in the documentation of the struct.
                           </div>
                           <p class="p">Exception reporting is only supported on Fermi (sm_20 or greater). </p>
                        </div>
                     </div>
                  </div>
                  <div class="topic reference cuda_reference nested1" id="r_attach"><a name="r_attach" shape="rect">
                        <!-- --></a><h3 class="topictitle3">2.5.&nbsp;Attaching and Detaching</h3>
                     <div class="body refbody">
                        <div class="section">
                           <p class="p">The debug client must take the following steps to attach to a running CUDA application:</p>
                           <ol class="ol">
                              <li class="li">
                                 <p class="p">Attach to the CPU process corresponding to the CUDA application. The CPU part of the application will be frozen at this point.</p>
                              </li>
                              <li class="li">
                                 <p class="p">Check to see if the CUDBG_IPC_FLAG_NAME variable is accessible from the memory space of the application. If not, it implies
                                    that the application has not loaded the CUDA driver, and the attaching to the application is complete.
                                 </p>
                              </li>
                              <li class="li">
                                 <p class="p">Make a dynamic function call to the function cudbgApiInit() with an argument of "2", i.e., "cudbgApiInit(2)". This causes
                                    a helper process to be forked off from the application, which assists in attaching to the CUDA process.
                                 </p>
                              </li>
                              <li class="li">
                                 <p class="p">Ensure that the initialization of the CUDA debug API is complete, or wait till API initialization is successful.</p>
                              </li>
                              <li class="li">
                                 <p class="p">Make the "initializeAttachStub()" API call to initialize the helper process that was forked off from the application earlier.</p>
                              </li>
                              <li class="li">
                                 <p class="p">Read the value of the CUDBG_RESUME_FOR_ATTACH_DETACH variable from the memory space of the application:</p>
                                 <ul class="ul">
                                    <li class="li">
                                       <p class="p">If the value is non-zero, resume the CUDA application so that more data can be collected about the application and sent to
                                          the debugger. When the application is resumed, the debug client can expect to receive various CUDA events from the CUDA application.
                                          Once all state has been collected, the debug client will receive the event CUDBG_EVENT_ATTACH_COMPLETE.
                                       </p>
                                    </li>
                                    <li class="li">
                                       <p class="p">If the value is zero, there is no more attach data to collect. Set the CUDBG_IPC_FLAG_NAME variable to 1 in the application's
                                          process space, which enables further events from the CUDA application.
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                              <li class="li">
                                 <p class="p">At this point, attaching to the CUDA application is complete and all GPUs belonging to the CUDA application will be suspended.</p>
                              </li>
                           </ol>
                        </div>
                        <div class="section">
                           <p class="p">The debug client must take the following steps to detach from a running CUDA application:</p>
                           <ol class="ol">
                              <li class="li">
                                 <p class="p">Check to see if the CUDBG_IPC_FLAG_NAME variable is accessible from the memory space of the application, and that the CUDA
                                    debug API is initialized. If either of these conditions is not met, treat the application as CPU-only and detach from the
                                    application.
                                 </p>
                              </li>
                              <li class="li">
                                 <p class="p">Next, make the "clearAttachState" API call to prepare the CUDA debug API for detach.</p>
                              </li>
                              <li class="li">
                                 <p class="p">Make a dynamic function call to the function cudbgApiDetach() in the memory space of the application. This causes CUDA driver
                                    to setup state for detach.
                                 </p>
                              </li>
                              <li class="li">
                                 <p class="p">Read the value of the CUDBG_RESUME_FOR_ATTACH_DETACH variable from the memory space of the application. If the value is non-zero,
                                    make the "requestCleanupOnDetach" API call.
                                 </p>
                              </li>
                              <li class="li">
                                 <p class="p">Set the CUDBG_DEBUGGER_INITIALIZED variable to 0 in the memory space of the application. This makes sure the debugger is reinitialized
                                    from scratch if the debug client re-attaches to the application in the future.
                                 </p>
                              </li>
                              <li class="li">
                                 <p class="p">If the value of the CUDBG_RESUME_FOR_ATTACH_DETACH variable was found to be non-zero in step 4, delete all breakpoints and
                                    resume the CUDA application. This allows the CUDA driver to perform cleanups before the debug client detaches from it. Once
                                    the cleanup is complete, the debug client will receive the event CUDBG_EVENT_DETACH_COMPLETE.
                                 </p>
                              </li>
                              <li class="li">
                                 <p class="p">Set the CUDBG_IPC_FLAG_NAME variable to zero in the memory space of the application. This prevents any more callbacks from
                                    the CUDA application to the debugger.
                                 </p>
                              </li>
                              <li class="li">
                                 <p class="p">The client must then finalize the CUDA debug API.</p>
                              </li>
                              <li class="li">
                                 <p class="p">Finally, detach from the CPU part of the CUDA application. At this point all GPUs belonging to the CUDA application will be
                                    resumed.
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                  </div>
               </div>
               
               <hr id="contents-end"></hr>
               
            </article>
         </div>
      </div>
      <script language="JavaScript" type="text/javascript" charset="utf-8" src="../common/formatting/common.min.js"></script>
      <script language="JavaScript" type="text/javascript" charset="utf-8" src="../common/scripts/google-analytics/google-analytics-write.js"></script>
      <script language="JavaScript" type="text/javascript" charset="utf-8" src="../common/scripts/google-analytics/google-analytics-tracker.js"></script>
      <script type="text/javascript">var switchTo5x=true;</script><script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script><script type="text/javascript">stLight.options({publisher: "998dc202-a267-4d8e-bce9-14debadb8d92", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script></body>
</html>